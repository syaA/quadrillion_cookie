

(defparameter *cookie* 0)
(defparameter *cps* 0)
(defparameter *product* nil)

(defparameter +product-base+
  '((cursor 15 0.1)
    (grandma 100 0.5)
    (farm 500 2)
    (factory 3000 10)
    (mine 10000 40)
    (shipment 40000 100)
    (alchemy-lab 200000 400)
    (portal 1666666 6666)
    (time-machine 124567789 98765)
    (antimatter-condenser 3999999999 999999)))

(defun reset ()
  (setf *cookie* 15)
  (setf *cps* 0.0)
  (setf *product* (make-hash-table))
  (mapc #'(lambda (x)
            (setf (gethash (car x) *product*) `(0 ,(cadr x)))) +product-base+))

(defun comma-separated-float-string (n)
  (multiple-value-bind (f e) (floor n)
    (format nil "~:D.~A" f (char (format nil "~F" e) 2))))

(defun puts-info ()
  (format t "~:D cookies. ~A cookies per second.~%"
          (floor *cookie*) (comma-separated-float-string *cps*))
  (dolist (base +product-base+)
    (let ((info (gethash (car base) *product*)))
      (format t "[~20A ~4D]~%" (car base) (car info)))))

(defun product-num (product)
  (car (gethash product *product*)))
(defun product-price (product)
  (floor
   (* (cadr (gethash product *product*))
      (expt 1.15 (product-num product)))))
(defun product-gain (product)
  (caddr (assoc product +product-base+)))

(defun buy-product (product)
  (when (>= *cookie* (product-price product))
    (decf *cookie* (product-price product))
    (incf (car (gethash product *product*)))
    (incf *cps* (caddr (assoc product +product-base+)))))

(defun simulate-step-random ()
  (buy-product (car (nth (random 10) +product-base+))))

(defun simulate-step-after-t (wait)
  (lambda ()
    (let ((most-eff 0) (cand))
      (dolist (product +product-base+)
        (let ((eff
               (if (<= (product-price (car product)) *cookie*)
                   (+ (- *cookie* (product-price (car product)))
                      (* (+ *cps* (caddr product)) wait))
                 (if (> *cps* 0)
                     (* (- wait (/ (- (product-price (car product)) *cookie*)
                                   *cps*))
                        (+ *cps* (caddr product)))))))
          (when (and eff (> eff most-eff))
            (setf most-eff eff)
            (setf cand (car product)))))
      (when cand
        (buy-product cand)))))

(defun simulate-step-after-t2 (wait)
  (lambda ()
    (let ((most-eff 0) (cand))
      (dolist (product +product-base+)
        (let ((eff
               (if (<= (product-price (car product)) *cookie*)
                   (* (caddr product) wait)
                 (if (> *cps* 0)
                     (* (- wait (/ (- (product-price (car product)) *cookie*)
                                   *cps*))
                        (caddr product))))))
          (when (and eff (> eff most-eff))
            (setf most-eff eff)
            (setf cand (car product)))))
      (when cand
        (buy-product cand)))))

(defun simulate-step-after-t-adaptive ()
  (let ((max-price 0) (cand) (wait))
    (dolist (product +product-base+)
      (when (> (product-price (car product)) max-price)
        (setf max-price (product-price (car product)))
        (setf cand (car product))))
    (if (and (> *cps* 0) (> max-price *cookie*))
        (setf wait (+ (/ (- max-price *cookie*) *cps*)
                      (/ max-price (+ *cps* (product-gain cand)))))
      (setf wait 1))
    (setf wait (min wait 3600))
    (let ((most-eff 0) (cand))
      (dolist (product +product-base+)
        (let ((eff
               (if (<= (product-price (car product)) *cookie*)
                   (+ (- *cookie* (product-price (car product)))
                      (* (+ *cps* (caddr product)) wait))
                 (if (> *cps* 0)
                     (* (- wait (/ (- (product-price (car product)) *cookie*)
                                   *cps*))
                        (+ *cps* (caddr product)))))))
          (when (and eff (> eff most-eff))
            (setf most-eff eff)
            (setf cand (car product)))))
      (when cand
        (buy-product cand)))))

(defun simulate (simulate-func time)
  (reset)
  (let ((alltime 0))
    (dotimes (n time)
      (incf *cookie* *cps*)
      (incf alltime *cps*)
      (funcall simulate-func))
    (format t "~:D baked cookies.~%" (floor alltime))
    (puts-info)
    `(,alltime ,*cookie* ,*cps*)))

(let ((c 0) (cps 0))
  (dotimes (n 10 `(,(mod c 10) ,(mod cps 10)))
    (simulate #'simulate-step-random 100000)
    (incf c *cookie*)
    (incf cps *cps*)))
